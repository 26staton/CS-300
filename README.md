# CS-300
DSA: Analysis and Design

Coursework for SNHU's CS-300: Data Structures and Algorithms

What was the problem you were solving in the projects for this course?

In what specific manner does the most successful strategy for addressing an issue look like? In this particular circumstance, the issue that needed to be addressed was specifically which data format is the most effective for constructing a product that loads course content and then offers for ways of modifying or retrieving that data. In general, the approach for resolving the problem comprises searching for a technique that is either the most efficient or the fastest, depending on the circumstances. However, the majority of the time, the strategy involves searching for the method that is the most effective. It may be necessary to pick the suitable technique to carry out the work at hand, or it may be necessary to select the proper data format depending on the circumstances. When attempting to find a solution to a problem, it is often important to take into consideration each and every one of these aspects before arriving at a conclusion.

How did you approach the problem? Consider why data structures are important to understand.

I made an attempt to strike a balance between a number of different concerns, such as which would be the most useful if this project were to continue to develop and expand in the years to come. For example, if this project were to continue to grow and expand in the years to come. Building a system that is not capable of being scaled is a complete and utter waste of effort and money. In addition to this, I made an effort to take into mind the efficiency with which the memory was utilized, as well as the speed with which fresh data could be uploaded or retrieved. In conclusion, one of the factors that must, at the at least, be taken into consideration is how easy it will be to put the plan into action. If a project takes one hundred percent more time but only yields a five to ten percent gain in quality, the client may not consider this to be a noteworthy change in the product.

How did you overcome any roadblocks you encountered while going through the activities or project?

I relied heavily on the materials that were available on the internet, such as Stack Overflow, YouTube tutorials, Geeks for Geeks, and a wide range of other C++ references. Because I began working on these projects so early, I was typically able to find a solution to any obstacles that interrupted my progress. In some cases, however, I was unable to do so. I also make it a point to remind myself to take pauses, walk away, and reflect in order to keep my mind from being too concentrated on a particular component of a job. This helps avoid my mind from being overwhelmed with the task at hand. finally I just remember why I taking this courses this late in my life and I get the work done.

How has your work on this project expanded your approach to designing software and developing programs?

Working with this project expanded my thoughts on how to look at a code.  The initial writing of the code was easy and took a few hours. It was the deep dive into refining and adjusting the code on how I wanted it to appear.  Using professionals in the field was a great resources and reading other code to spark ideas is essential to building your own product.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

In spite of the fact that I would like to think I have a deeper comprehension of what it is that makes comments in code beneficial, I discovered that this was the field in which I felt the most comfortable. In terms of adaptability, it taught me a lot about thinking about what extra possibilities may develop with the product, such as questioning whether or not it is ready for a new feature or for a massive flood of data in the event that it were to occur. In addition, it taught me a lot about thinking about what more possibilities may come with the product. In the past, I hadn't really given that much attention to making sure that I take all of those factors into consideration, which is something that I'm going to start doing now. Last but not least, an analogous thought came to me about maintainability. It helped me better understand the concept of modularity since I don't want to have to redo every part of my code if anything has to be adjusted. Because of this, I've discovered that it's more important for me to have solid object-oriented concepts in mind as I design software. This is because it makes maintenance more difficult.
